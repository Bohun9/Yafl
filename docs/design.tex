\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{bussproofs}
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage{float}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{syntax}

\geometry{margin=0.3in}
\geometry{
    left=2cm,
    right=2cm,
    bottom=1.5cm,
    top=1.5cm,
}


\newcommand{\pl}{\langle}
\newcommand{\pr}{\rangle}
\newcommand{\rec}[1]{\langle#1\rangle}
\newcommand{\bld}[1]{\mathbf{#1}}
\newcommand{\mt}{\mapsto}
\newcommand{\rd}{\rightsquigarrow}
\newcommand\Denot[1]{\llbracket#1\rrbracket}
\newcommand*{\impl}{\mathbin{\to}}
\newcommand\deq{\quad\stackrel{\mathclap{\normalfont\mbox{def}}}{=}\quad}
\newcommand{\liff}{\leftrightarrow}
\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\green}[1]{{\color{green} #1}}
\newcommand{\blue}[1]{{\color{blue} #1}}
\newcommand{\orange}[1]{{\color{orange} #1}}
\newcommand{\yellow}[1]{{\color{yellow} #1}}
\newcommand{\purple}[1]{{\color{purple} #1}}
\newcommand{\lam}[1]{\lambda#1\ldotp}
\newcommand{\Lam}{\Lambda}
\newcommand{\unl}[1]{\underline{#1}}
\newcommand{\mb}[1]{\mathbf{#1}}
\newcommand{\cm}[0]{\checkmark}
\newcommand{\msar}[0]{\twoheadrightarrow}
\newcommand{\bl}{\{}
\newcommand{\br}{\}}


\title{Yet Another Functional Language}
\author{Marcin Martowicz}
\date{}

\begin{document}
\maketitle

\section{Introduction}
In this document, I provide a brief summary of the compilation pipeline for a standard functional language targeting the LLVM infrastructure.
The key features covered include:
\begin{itemize}
    \item Higher-order functions
    \item Algebraic data types
    \item Deep pattern matching
\end{itemize}

\section{Intermediate Representations}

\subsection{Surface}
The high-level AST, directly reflecting the user's syntax.

\subsection{Desugared}
A desugared version of the Surface IR. Deep pattern matching is compiled into shallow pattern matching to simplify type checking.

\subsection{Typed}
Each node is annotated with explicit type information.

\subsection{ANF}
This representation introduces records and C-like type casts.
Memory layouts are chosen for algebraic data types and shallow pattern matching is compiled into switch statements.
The computations are explicitly ordered by using \texttt{let} constructs, resulting in A-Normal Form (ANF).
This stage is suitable for optimizations such as function inlining.

\subsection{Core}
Closure conversion is performed, ensuring that all functions are closed and can be hoisted to the top level.
This representation is structured to make translation to LLVM straightforward.

\section{Implementation}

\subsection{Source Position}
A neat way to include source position information in the AST nodes is to use a wrapper type:
\begin{verbatim}
data Node a = Node { pos :: AlexPosn, data :: a }

type Expr = Node ExprData

data ExprData
  = EApp Expr Expr
  ...
\end{verbatim}
The Node type definition can be reused across multiple IRs.

\subsection{Type Information}
Type information from the typechecker could be added to each node using the \texttt{Node} type, or explicitly to the constructors' fields. 
The second option is worth considering, as only a subset of types are relevant for LLVM compilation.
However, the first option enables type checking of the intermediate representations.

\subsection{Other Information}
It is convinient to add an addtional \texttt{tag} field to the \texttt{Node} type, allowing any other necessary information to be stored using mappings.
\begin{verbatim}
data Node a = Node { tag :: Tag, data :: a }
\end{verbatim}

\section{Algebraic Data Types}
\begin{verbatim}
data bst = 
  | Leaf
  | Node of bst int bst

let tree = Node(Leaf, 3, Leaf)

let sum (t : bst) : int = 
  match t with
  | Leaf -> 0
  | Node(t1, n, t2) -> n + (sum t1) + (sum t2)
\end{verbatim}

\subsection{Memory Representation}
A value of an algebraic data type is a pointer to a block of memory that consists of the constructor tag and the fields of that constructor.

\begin{verbatim}
let leaf = {0}
let tree = {1, leaf, 3, leaf}
\end{verbatim}

\subsection{Typing}
All values of the same algebraic data type should have the same type.
The simplest solution is to hide the fields when a value is created and
introduce it back when performing the pattern matching.

\begin{verbatim}
let leaf = cast *{int} {0}
let tree = cast *{int} {1, leaf, 3, leaf}

let sum (t : *{int}) : int = 
  let tag = t#0 in
  switch tag with
  | 0 -> 0
  | 1 ->
    let t' = cast *{int, *{int}, int, *{int}} t
    let t1 = t'#1
    let n  = t'#2
    let t2 = t'#3
    in
    n + (sum t1) + (sum t2)
\end{verbatim}

\section{Higher-order Functions}
\begin{samepage}
    \begin{verbatim}
let add x =
  let f y = 
    x + y
  in
  f
...
let add1 = add 1

let dft = 1
let fact n =
  if n == 0 then
    dft
  else
    n * fact (n - 1)
\end{verbatim}
\end{samepage}

\subsection{Memory Representation}
A value of a function type is a pointer to a block of memory that consists of a function code pointer
and an environment that provides the values of free variables of the function.
The environment can be represented as the flat sequence of values, or be based on the static links which enables sharing of data.
This representation of functions is called a closure, because it closes each function, so that it does not have any free variables.
Each function gets one additional parameter which denotes its closure or environment, depending on the design.
The advantage of the closure as the parameter is that it can be used for elegant compilation of recursive functions such as \texttt{fact}.
Each reference to a free variable inside the function is replaced by an explicit lookup in the environment structure.

I pick the approach based on the static links, because it should be easy to implement and it minimizes the memory usage, which
is important for a language without garbage collection. Each function allocates its environment at the entry and stores
a pointer to the enclosing function's environment in its first field. The variables that are referenced inside nested functions
must be saved in this environment.

\begin{verbatim}
fun f_code f y = 
  let env     = f#1
  let cur_env = {env} // not used
  let x       = env#1
  in
  x + y

fun add_code add x = 
  let env     = add#1
  let cur_env = {env, x}
  let f       = {f_code, cur_env}
  in
  f

fun some_fun_code ... =
  ...
  let add = {add_code, cur_env}
  ...
  let add_code = add#0
  let add1 = add_code(add, 1)

fun fact_code fact n = 
  let env     = fact#1
  let cur_env = {env} // not used
  if n == 0 then
    env#dft
  else
    let fact_code = fact#0 in
    n * fact_code(fact, n - 1)
\end{verbatim}

\subsection{Typing}
It is helpful to split this problem into smaller ones.

\subsubsection{Change of The Function Representation}
Functions in the Core IR are represented as closures. It suggests that there is an interesting case in the translation of types:
\begin{align*}
    \Denot{\tau_1\impl\tau_2} = *(*(\Denot{\tau_1\impl\tau_2} \times \Denot{\tau_1} \impl \Denot{\tau_2}) \times \text{env}_\text{type})
\end{align*}
Each function of the type $\tau_1\impl\tau_2$ should get the same type after the translation.
To achieve that, we can cast $\text{env}_\text{type}$ to \texttt{*void} when creating the closures.
Each function can cast its environment argument back to its real type at the entry.

\subsubsection{Infinite Parameter Type}
In each well-typed program the type of a function is structurally bigger than types of its arguments.
In our case it is not true, because each function gets its closure as an argument.
If we chose to pass the environment, there is no such problem. 
To overcome this issue, we can set the type of the closure parameter to be \texttt{*void}:
\begin{align*}
    \Denot{\tau_1\impl\tau_2} = *(*(*\text{void} \times \Denot{\tau_1} \impl \Denot{\tau_2}) \times *\text{void})
\end{align*}

\subsubsection{Summary}
Let's compile a function of type $\tau_1\impl\tau_2$ with all needed casts.

\begin{verbatim}
fun fn_code (fn : *void) (param : [tau_1]) : [tau_2] = 
  // 1. Cast the closure parameter to its standard type
  let fn = cast [tau_1 -> tau_2] fn
  // 2. Cast the environment to its real type
  let env = cast enclosing_env_type (fn#1)
  // 3. Create the current environment that can be filled later
  let cur_env = {env, param, 0, ..., 0}
  // 4. Cast the current environment for the closure creation
  let void_cur_env = cast *void cur_env
  ...
  ...
  ...
  // Lookup to the enclosing environment
  let var1 = env#3 + 100
  // Update of the current environment
  cur_env#5 = var1
  ...
  // Closure creation
  let clo = {clo_code, void_cur_env}
  ...
  // Closure application
  let clo_code = clo#0
  let void_clo = cast *void clo
  clo_code(void_clo, arg)
  ...
\end{verbatim}

\section{Deep Pattern Matching}
The standard pattern matching compiler uses the \texttt{match} function, which solves
the following pattern matching instance problem.
\[
\begin{array}{ccccccc}
    u_1 & u_2 & \dots & u_m \\ \hline
    p_{11} & p_{12} & \dots & p_{1m} & \rightarrow & e_1 \\
    p_{21} & p_{22} & \dots & p_{2m} & \rightarrow & e_2 \\
    \vdots & \vdots &       & \vdots & \vdots      & \vdots \\
    p_{n1} & p_{n2} & \dots & p_{nm} & \rightarrow & e_n
\end{array}
\]
The key for efficient compilation is the use of \texttt{PatternMatchingSeq(e1, e2)} in the target language.
If the pattern match fails in $e_1$, execution should continue at $e_2$, which represents the next series of cases to check.
It can be expressed by jumping
to labels and can be done only in the IR with explicit basic blocks - in our case LLVM.

\begin{verbatim}
// Surface
match xs, ys with
| []  , []   -> 0
| x:xs, y:ys -> 1

// Desugared
(case xs of
| [] -> case ys of ->
        | [] -> 0
| x:xs -> case ys of 
        | y:ys -> 1)
|| PatternMatchingError

// LLVM (simplified)
L0:
  switch xs.tag of
  | 0 -> br L1
  | 1 -> br L2
  | _ -> br L_error
L1:
  switch ys.tag of
  | 0 -> br L_constant0
  | _ -> br L_error
L_constant0:
  br L_merge
L2:
  switch ys.tag of
  | 1 -> br L_constant1
  | _ -> br L_error
L_constant1:
  br L_merge
L_error:
  print "pattern matching error"
  call exit
  br L_merge
L_merge:
  res = phi [(0, L_constant0), (1, L_constant1), (undef, L_error)]

    
\end{verbatim}

\end{document}

